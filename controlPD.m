#Compensacion con CONTROLADOR PD pkg load control pkg load signal clearclcNum = 1; Den = [1 4 0]; sys = tf(Num,Den);Zita = 0.8;Wn = 5; H=1;  #Calculo de punto de prueba que cumple la condicion sigma = Zita*Wn Wd = sqrt(Wn^2 - sigma^2); PuntoD = complex(-sigma,Wd)Polos = roots(Den);Ceros = roots(Num);printf("Los polos que se pueden cancelar son \n"); for i=1:length(Polos)  if(Polos(i))   printf("%.3f \n",Polos(i))   endifendfor#ALGORITMO PARA CONDICION DE ANGULO PARA POLOSfor i = 1:length(Polos)if( real(Polos(i) > real(PuntoD)) )   denominador = abs(Polos(i) - real(PuntoD));   coord = imag(PuntoD) / denominador;   angulo(i) = 180 - (atan(coord)*(180/pi));   angulo(i) = -1*angulo(i); else   denominador = abs(Polos(i) - real(PuntoD));   if(denominador)  coord = imag(PuntoD) / denominador;   angulo(i) = (atan(coord)*(180/pi));   angulo(i)= -1*angulo(i);  else   angulo(i) = -90; endif endifendfor #Para CerosCeros = roots(Num);for i = 1:length(Ceros)if( real(Ceros(i) > real(PuntoD)) )   denominador = abs(Ceros(i) - real(PuntoD));   coord = imag(PuntoD) / denominador;   angulo = [angulo; (180 - (atan(coord)*(180/pi))) ]; else   denominador = abs(Ceros(i) - real(PuntoD));   if(denominador)    coord = imag(PuntoD) / denominador;     angulo = [angulo;((atan(coord)*(180/pi)))];   else     angulo = [angulo;90]; endif endifendfor %-----------CompensanciÃ³n-----------Total = sum(angulo) i=0; if(abs(Total)>180)  do     ang = 180 * (2*i + 1)    i+=1;  until(ang < abs(Total));else  ang = 0; endifAnguloCompensacion = ang + Total AnguloCompensacionABS = abs(AnguloCompensacion); if(AnguloCompensacion>0)printf("Este metodo no es el apropiado, se deberia agregar un polo y no un cero")pause(2); exit;  endifCeroNuevo = (imag(PuntoD) / tan(deg2rad(AnguloCompensacionABS))) + abs(real(PuntoD)); CeroNuevo *= -1;Ceros = [Ceros;CeroNuevo];Td = abs(1/CeroNuevo);  NumC = [1 -CeroNuevo]; DenC = [1];  %Calculo de K  Knum = 1; Kden= 1;  for i = 1:(length(Polos))   Knum *=  (PuntoD -  Polos(i));    endforKnum = abs(Knum);   for i = 1:(length(Ceros))    Kden *= (PuntoD - Ceros(i));     endforKden = abs(Kden); K = Knum / Kden; printf("La funcion del controlador es \n"); Gc = tf(NumC,DenC)Kp = K/Td;  Gc = K*Gcprintf("La funcion a lazo abierto GH = \n")GH= series(sys,Gc);GH = series(GH,H)printf("La funcion a lazo cerrado es : \n");FS = series(Gc,sys); FS = feedback(FS,H)[z,p,k] = zpkdata(FS) 