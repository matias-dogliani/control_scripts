#Compensacion con: Cancelacion de Polo pkg load controlpkg load signal clearclcNum = 1; Den = [1 4 0]; sys = tf(Num,Den);Zita = 0.8;Wn = 5; H=1; #Calculo de punto de prueba que cumple la condicion sigma = Zita*Wn Wd = sqrt(Wn^2 - sigma^2); PuntoD = complex(-sigma,Wd)PuntoD = -2 + 2i; Polos = roots(Den);Ceros = roots(Num);printf("Los polos que se pueden cancelar son \n"); for i=1:length(Polos)  if(Polos(i))   printf("%.3f \n",Polos(i))   endifendfor#ALGORITMO PARA CONDICION DE ANGULO PARA POLOSfor i = 1:length(Polos)if( real(Polos(i) > real(PuntoD)) )   denominador = abs(Polos(i) - real(PuntoD));   coord = imag(PuntoD) / denominador;   angulo(i) = 180 - (atan(coord)*(180/pi));   angulo(i) = -1*angulo(i); else   denominador = abs(Polos(i) - real(PuntoD));   if(denominador)    coord = imag(PuntoD) / denominador;     angulo(i) = (atan(coord)*(180/pi));     angulo(i)= -1*angulo(i);  else     angulo(i) = -90;  endif endifendfor #Para CerosCeros = roots(Num);for i = 1:length(Ceros)if( real(Ceros(i) > real(PuntoD)) )   denominador = abs(Ceros(i) - real(PuntoD));   coord = imag(PuntoD) / denominador;   angulo = [angulo; (180 - (atan(coord)*(180/pi))) ]; else   denominador = abs(Ceros(i) - real(PuntoD));   if(denominador)    coord = imag(PuntoD) / denominador;     angulo = [angulo;((atan(coord)*(180/pi)))];   else     angulo = [angulo;90]; endif endifendfor %-----------Compensanción-----------Total = sum(angulo);AnguloTotal = Totali=0; if(abs(Total)>180)  do     ang = 180 * (2*i + 1);    i+=1;  until(ang < abs(Total));else  ang = 0; endif AnguloCompensacion = ang + Total + 90AnguloCompensacionABS = abs(AnguloCompensacion); PoloNuevo = (imag(PuntoD) / tan(deg2rad(AnguloCompensacionABS))) + abs(real(PuntoD)); PoloNuevo *= -1;#PoloCancelado = -2;PoloCancelado = input("Ingrese el polo a cancelar (con signo):  "); Numc = [1 -PoloCancelado]; Denc = [1 -PoloNuevo];  %Calculo de K  Knum = 0; for i = 0:(length(Polos))   if(i==0)   Knum = PuntoD - PoloNuevo;   else   Knum *=  (PuntoD -  Polos(i));   endif endforKnum = abs(Knum);  kden= 0; for i = 0:(length(Ceros))   if(i==0)   Kden= PuntoD - PoloCancelado;   else   Kden *= ( PuntoD -  Ceros(i) );   endif endforKden = abs(Kden); K = Knum / Kden printf("La funcion del controlador es \n"); Gc = tf(Numc,Denc)K Gc = K*tf(1,Denc) %Porque en el numerador está el polo que se cancela con la G de plantaprintf("La funcion a lazo abierto GH = \n")NumSys = Num; j=1for i=1:length(Polos) %Aca cancelo el polo   if(Polos(i) != PoloCancelado)    DenSys(j) = Polos(i);    j += 1;  endifendforDenSys = poly(DenSys); %las raices las pasos a coeficientes de polinomiosGH= series(tf(NumSys,DenSys),Gc);GH = series(GH,H)printf("La funcion a lazo cerrado es : \n");FS = series(Gc,sys); FS = feedback(FS,H)[z,p,k] = zpkdata(FS) clear